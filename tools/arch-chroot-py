#!/usr/bin/env python3
"""
Python implementation of arch-chroot command.

This provides the same functionality as the original bash arch-chroot script
but uses the Python chroot module from kod.lib for the implementation.
"""

import sys
import os
import argparse
from pathlib import Path

# Add the src directory to the Python path so we can import from kod.lib
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

try:
    from kod.lib.chroot import Chroot, ChrootError
except ImportError as e:
    print(f"Error: Could not import chroot module: {e}", file=sys.stderr)
    print("Make sure you're running this from the project root directory.", file=sys.stderr)
    sys.exit(1)


class ArchChrootPy:
    def __init__(self):
        self.unshare_mode = False
        self.userspec = None

    def usage(self):
        return """usage: arch-chroot-py chroot-dir [command] [arguments...]

    -h                  Print this help message
    -N                  Run in unshare mode as a regular user (not implemented)
    -u <user>[:group]   Specify non-root user and optional group to use (not implemented)

If 'command' is unspecified, arch-chroot-py will launch /bin/bash.

Note that when using arch-chroot-py, the target chroot directory *should* be a
mountpoint. This ensures that tools such as pacman(8) or findmnt(8) have an
accurate hierarchy of the mounted filesystems within the chroot.

If your chroot target is not a mountpoint, you can bind mount the directory on
itself to make it a mountpoint, i.e. 'mount --bind /your/chroot /your/chroot'.
"""

    def arch_chroot(self, chrootdir: str, command: list = None):
        """Execute arch-chroot functionality using the Python chroot module."""
        if os.geteuid() != 0:
            print("Error: This script must be run with root privileges", file=sys.stderr)
            sys.exit(1)

        if not os.path.isdir(chrootdir):
            print(f"Error: Can't create chroot on non-directory {chrootdir}", file=sys.stderr)
            sys.exit(1)

        # Check if it's a mountpoint (warning only)
        try:
            import subprocess
            result = subprocess.run(['mountpoint', '-q', chrootdir], capture_output=True)
            if result.returncode != 0:
                print(f"Warning: {chrootdir} is not a mountpoint. This may have undesirable side effects.", 
                      file=sys.stderr)
        except FileNotFoundError:
            # mountpoint command not available, skip check
            pass

        # Prepare command
        if not command:
            cmd = ["/bin/bash"]
        else:
            # Pass command arguments as a list
            cmd = command

        # Execute using the chroot module
        try:
            chroot_instance = Chroot()
            chroot_instance.execute(chrootdir, cmd, get_output=False)
        except ChrootError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
        except KeyboardInterrupt:
            sys.exit(130)
        except Exception as e:
            print(f"Unexpected error: {e}", file=sys.stderr)
            sys.exit(1)

    def run(self, args):
        """Main entry point for the script."""
        # Handle the case where command arguments might start with dashes
        # by manually parsing the arguments
        
        # First, separate our tool's options from the chroot command
        tool_args = []
        chrootdir = None
        command_args = []
        
        i = 0
        while i < len(args):
            arg = args[i]
            
            if arg in ['-h', '--help']:
                # Show help and exit
                parser = argparse.ArgumentParser(
                    description="Python implementation of arch-chroot",
                    formatter_class=argparse.RawDescriptionHelpFormatter,
                    epilog="""If 'command' is unspecified, arch-chroot-py will launch /bin/bash.

Note that when using arch-chroot-py, the target chroot directory *should* be a
mountpoint. This ensures that tools such as pacman(8) or findmnt(8) have an
accurate hierarchy of the mounted filesystems within the chroot.

If your chroot target is not a mountpoint, you can bind mount the directory on
itself to make it a mountpoint, i.e. 'mount --bind /your/chroot /your/chroot'."""
                )
                parser.add_argument('-N', '--unshare', action='store_true', help='Run in unshare mode as a regular user (not implemented)')
                parser.add_argument('-u', '--userspec', metavar='USER[:GROUP]', help='Specify non-root user and optional group to use (not implemented)')
                parser.add_argument('chrootdir', help='Target chroot directory')
                parser.add_argument('command', nargs='*', help='Command and arguments to run in chroot')
                parser.print_help()
                sys.exit(0)
            elif arg in ['-N', '--unshare']:
                tool_args.append(arg)
                self.unshare_mode = True
                i += 1
            elif arg in ['-u', '--userspec']:
                tool_args.extend([arg, args[i + 1] if i + 1 < len(args) else ''])
                self.userspec = args[i + 1] if i + 1 < len(args) else None
                i += 2
            elif arg.startswith('-'):
                print(f"Error: Unknown option '{arg}'", file=sys.stderr)
                sys.exit(1)
            else:
                # This should be the chrootdir, everything after is command
                chrootdir = arg
                command_args = args[i + 1:]
                break
            
        if chrootdir is None:
            print("Error: Missing required argument 'chrootdir'", file=sys.stderr)
            print("Use -h or --help for usage information", file=sys.stderr)
            sys.exit(1)

        # Warn about unimplemented features
        if self.unshare_mode:
            print("Warning: Unshare mode (-N) is not yet implemented", file=sys.stderr)
        if self.userspec:
            print("Warning: User specification (-u) is not yet implemented", file=sys.stderr)

        # Execute arch-chroot
        self.arch_chroot(chrootdir, command_args if command_args else None)


def main():
    """Main entry point when run as a script."""
    arch_chroot_py = ArchChrootPy()
    arch_chroot_py.run(sys.argv[1:])


if __name__ == "__main__":
    main()